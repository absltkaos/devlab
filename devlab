#!/usr/bin/env python
# vim: set syntax=python et ts=4 sw=4 sts=4:
"""
Main script for managing the devlab environment stack
"""
import argparse
import json
import logging
import os
import platform
import sys

import devlab_bench.actions
import devlab_bench
from devlab_bench.helpers.command import Command
from devlab_bench.helpers.common import get_components, get_config, get_shell_components
from devlab_bench.helpers.docker import DockerHelper
from devlab_bench.exceptions import DevlabComponentError

##- Variables -##
ARGS = None
PARSER = None
LOGGER = None
LOGGING_LEVELS = {
    'debug': logging.DEBUG,
    'info': logging.INFO,
    'warning': logging.WARNING,
    'error': logging.ERROR,
    'critical': logging.CRITICAL,
    'notset': logging.NOTSET
}
__VERSION__ = 'master'

##- Functions -##

def action_default(**kwargs):
    """
    A default action that doesn't really do anything
    """
    ignored_args = kwargs
    PARSER.parse_args(['-h'])

def action_global_status(**kwargs):
    """
    Generates a global status of all environments spun up with devlab
    """
    ignored_args = kwargs
    global_devlab_docker = DockerHelper(
        filter_label='com.lab.type=devlab'
    )
    containers = global_devlab_docker.get_containers()[1]
    status_by_project = {}
    status_header = {
        'container_name': 'Container Name',
        'status': 'Status',
        'local_port': 'Docker exposed'
    }
    status_table_head = []
    status_header_format = "| {container_name:^21} | {status:^10} | {local_port:^32} |"
    status_row_format = "| {container_name:21} | {status:10} | {local_port:32} |"
    status_width = len(status_header_format.format(**status_header))
    status_table_bar = '{{:-<{}}}'.format(status_width)
    status_table_head.append(status_table_bar.format(''))
    status_table_head.append(status_header_format.format(**status_header))
    status_table_head.append(status_table_bar.format(''))
    for cont in containers:
        first_port = True
        exposed_ports = False
        status_row = {
            'container_name': cont['name'],
            'status': '',
            'local_port': ''
        }
        rows = []
        state = cont['status']
        details = global_devlab_docker.inspect_container(cont['name'])[0]
        labels = details['Config']['Labels']
        container_project = 'ORPHANED (Unknown project origin)'
        for label in labels:
            if label == 'com.lab.project':
                container_project = labels[label]
                break
        if 'up' in state.lower():
            status_row['status'] = 'up'
        else:
            status_row['status'] = 'stopped'
        for port in details['HostConfig']['PortBindings']:
            exposed_ports = True
            cont_port, port_proto = port.split('/')
            host_port = details['HostConfig']['PortBindings'][port][0]['HostPort']
            port_str = 'Host: {host_port}({proto}) -> Cont: {cont_port}'.format(proto=port_proto, host_port=host_port, cont_port=cont_port)
            if first_port:
                status_row['local_port'] = port_str
                rows.append(status_row)
                first_port = False
            else:
                rows.append({
                    'container_name': '',
                    'status': '',
                    'local_port': port_str
                })
        if not exposed_ports:
            rows.append(status_row)
        try:
            status_by_project[container_project] += rows
        except KeyError:
            status_by_project[container_project] = []
            status_by_project[container_project] += rows
    for project in status_by_project:
        print("##\n## Project: \n##  {}\n##".format(project))
        print('\n'.join(status_table_head))
        for row in status_by_project[project]:
            print(status_row_format.format(**row))
        print(status_table_bar.format(''))
        print('')
    sys.exit(0)

def action_update(uninstall=False, set_version=None, **kwargs):
    """
    Use the installer to try and update devlab to the latest version in the repo

    Args:
        uninstall: bool, indicating to uninstall instead of update
        set_version: str, indicating a specific version of devlab to install

    Returns:
        None (In fact this function should call sys.exit)
    """
    ignored_args = kwargs
    log = logging.getLogger("Run/Up")
    log.debug("Running installer.py to check for updates etc...")
    command = '{}/installer.py'.format(devlab_bench.DEVLAB_ROOT)
    args = []
    if uninstall and set_version:
        log.error("Cannot uninstall a specific version. Uninstall takes no argument")
        sys.exit(1)
    if uninstall:
        args.append('uninstall')
    if set_version:
        args += ['install', '--set-version', set_version]
    inst_out = Command(command, args, interactive=True).run()
    if inst_out[0] != 0:
        log.error("Installer did not exit successfully... Aborting!")
        sys.exit(1)
    sys.exit(0)

def get_runtime_images():
    """
    Try to get a list of available runtime images
    """
    config = get_config()
    if 'runtime_images' not in config:
        config = get_config(fallback_default=True)
        if 'runtime_images' not in config:
            return []
    runtime_images = list(config['runtime_images'].keys())
    runtime_images.sort()
    return runtime_images

def load_json_config(config_path):
    """
    Load the json config file at 'config_path' and return the dict
    """
    config = {}
    if os.path.isfile(config_path):
        with open(config_path, 'r') as cfile:
            config = json.load(cfile)
    return config

def logging_init(level):
    """
    Initialize and create initial LOGGER
    level is a String of one of:
        'debug'
        'info'
        'warning'
        'error'
        'critical'
        'notset'
    Colorizing was combining multiple ideas in the answers from:
        https://stackoverflow.com/q/384076
    """
    black, red, green, yellow, blue, magenta, cyan, white = range(8) # pylint: disable=unused-variable
    level_colors = {
        logging.WARNING  : 30 + yellow,
        logging.INFO     : 30 + green,
        logging.DEBUG    : 30 + white,
        logging.CRITICAL : 30 + yellow,
        logging.ERROR    : 40 + red
    }
    sequences = {
        'reset': "\033[0m",
        'color': "\033[1;%dm",
        'bold' : "\033[1m"
    }
    #Initialize logging
    try:
        log_level = int(level)
    except ValueError:
        log_level = LOGGING_LEVELS[level.lower()]
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    #Setup ANSI coloring for the log level name
    if platform.system() != 'Windows' and devlab_bench.ISATTY:
        for l_level in level_colors:
            logging.addLevelName(
                l_level,
                "{bold}{color_seq}{level_name}{reset}".format(
                    color_seq=sequences['color'] % level_colors[l_level],
                    level_name=logging.getLevelName(l_level),
                    **sequences
                )
            )

def set_default_action(args, subparser):
    """
    Look at the args passed and determine if there is a subparser action set for
    it. If there is, then return the normal set of args. If NOT then append the
    default 'none' action and return it.

    This is primarily to get around a shortcoming in python2 :-|

    Args:
        args: list, of the args passed to the script

    Returns:
        list
    """
    action_exists = False
    args_passed = list(args)
    for action in subparser.choices:
        if action in args_passed:
            action_exists = True
            break
    if not action_exists:
        args_passed.append('none')
    return args_passed

##- Main -##
if __name__ == '__main__':
    CUR_COMPONENTS = get_components()
    #Top level parser
    PARSER = argparse.ArgumentParser(description='Main interface for devlab')
    PARSER.add_argument('--log-level', '-l', choices=list(LOGGING_LEVELS.keys()), default='info', help='Set the log-level output')
    PARSER.add_argument('--version', '-v', action='store_true', help='Display the version of devlab and exit')
    PARSER.add_argument('--project-root', '-P', default=None, help='Force project root to a specific path instead of searching for DevlabConfig.json/DevlabConfig.yaml etc...')
    SUBPARSERS = PARSER.add_subparsers(help='Actions')

    #Add Subparser for dummy default action
    PARSER_DEFAULT = SUBPARSERS.add_parser('none')
    PARSER_DEFAULT.set_defaults(func=action_default)

    #Add Subparser for build action
    PARSER_BUILD = SUBPARSERS.add_parser('build', help='Build docker images')
    PARSER_BUILD.add_argument('images', nargs='*', choices=list(devlab_bench.IMAGES.keys()) + get_runtime_images() + ['*'], default='*', help='Build the specific image or images. Leave empty for all(*)')
    PARSER_BUILD.add_argument('--clean', '-c', action='store_true', help='Do a clean build, which will remove all images and then rebuild them')
    PARSER_BUILD.add_argument('--no-cache', '-C', action='store_true', help='Don\'t use docker\'s cache when building')
    PARSER_BUILD.add_argument('--pull', '-p', action='store_true', help='Try to pull the latest version of images during build')
    PARSER_BUILD.set_defaults(func=devlab_bench.actions.build.action)

    #Add Subparser for down action
    PARSER_DOWN = SUBPARSERS.add_parser('down', help='Bring down components')
    PARSER_DOWN.add_argument('components', nargs='*', default='*', type=get_components, help='Bring down the specific component(s) or glob matches to bring down. COMPONENTS: {}'.format(', '.join(CUR_COMPONENTS)))
    PARSER_DOWN.add_argument('--rm', '-r', action='store_true', help="Don't just bring the component down, but also delete the container")
    PARSER_DOWN.set_defaults(func=devlab_bench.actions.down.action)

    #Add Subparser for shell action
    PARSER_SHELL = SUBPARSERS.add_parser('sh', help='Execute a shell command inside of a component/container')
    PARSER_SHELL.add_argument('components', nargs='*', default='*', type=get_shell_components, help='The component(s) or globs where the shell/command should be run. If more than one component is specified the command will be run sequentially across the components. COMPONENTS: {}'.format(', '.join(CUR_COMPONENTS + ['adhoc'])))
    PARSER_SHELL.add_argument('--adhoc-image', '-i', default='devlab_helper', help='When using the \'adhoc\' component, use this image. [NOTE] This is overridden if --command is specified with \'helper_container|IMAGENAME: /bin/bash\' etc... DEFAULT: \'devlab_helper\'')
    PARSER_SHELL.add_argument('--adhoc-name', '-n', default=None, help='When using the \'adhoc\' component, use this name for the container.')
    PARSER_SHELL.add_argument('--command', '-c', nargs=argparse.REMAINDER, help='Optional command to run instead of an interactive shell')
    PARSER_SHELL.add_argument('--user', '-u', default=None, help='Optional user to run the command/shell as')
    PARSER_SHELL.set_defaults(func=devlab_bench.actions.shell.action)

    #Add Subparser for reset action
    PARSER_RESET = SUBPARSERS.add_parser('reset', help='Reset a specific component, getting rid of all data including persistent data. This is useful if you want to have a component start from scratch without re-running the wizard')
    PARSER_RESET.add_argument('targets', nargs='*', default='default', type=devlab_bench.actions.reset.get_reset_components, help='Reset the specific target(s) or glob matches. * means all components, but this does NOT inlcude other targets like \'devlab\'. TARGETS: {}'.format(', '.join(CUR_COMPONENTS + ['devlab'])))
    PARSER_RESET.add_argument('--reset-wizard', '-r', action='store_true', help='Also remove wizard related files so that the wizard will run again for the specified component')
    PARSER_RESET.add_argument('--full', '-f', action='store_true', help='Remove all component specific files, wizard files, as well as devlab files AND potentially files you\'re working on. BE CAREFUL IF YOU HAVE MANUAL CHANGES IN PATHS DEFINED IN YOUR \'paths.reset_full\'!!')
    PARSER_RESET.set_defaults(func=devlab_bench.actions.reset.action)

    #Add Subparser for global_status action
    PARSER_GLOBAL_STATUS = SUBPARSERS.add_parser('global-status', help='Get a global status of all environments where devlab has created containers')
    PARSER_GLOBAL_STATUS.set_defaults(func=action_global_status)

    #Add Subparser for status action
    PARSER_STATUS = SUBPARSERS.add_parser('status', help='Get a status of the environment')
    PARSER_STATUS.set_defaults(func=devlab_bench.actions.status.action)

    #Add Subparser for up action
    PARSER_UP = SUBPARSERS.add_parser('up', help='Bring up components')
    PARSER_UP.add_argument('components', nargs='*', default='*', type=get_components, help='Bring up the specific component(s) based on name or glob match. COMPONENTS: {}'.format(', '.join(CUR_COMPONENTS)))
    PARSER_UP.add_argument('--bind-to-host', '-b', action='store_true', help='Whether or not we should spin things up so that other systems on your host\'s network will be able to easily reach and work with the spun up components. This generally means if your host\'s IP changes, components will have to be reprovisioned')
    PARSER_UP.add_argument('--skip-provision', '-k', action='store_true', help='Bring up the components but don\'t run any scripts')
    PARSER_UP.add_argument('--keep-up-on-error', '-K', action='store_true', help='Whether to keep a component container running even if it encounters errors during provisioning scripts etc...')
    PARSER_UP.add_argument('--update-images', '-u', action='store_true', help='Look for images that components are using, and try to either build new versions, or pull new ones when bringing them "up"')
    PARSER_UP.set_defaults(func=devlab_bench.actions.up.action)

    # Add subparser for update action
    PARSER_UPDATE = SUBPARSERS.add_parser('update', help='Update devlab to the latest released version')
    PARSER_UPDATE.add_argument('--uninstall', '-U', action='store_true', help='Instead of updating using the installer, uninstall it')
    PARSER_UPDATE.add_argument('--set-version', '-V', default=None, help='Update/Downgrade to a specific version of devlab')
    PARSER_UPDATE.set_defaults(func=action_update)

    # Add subparser for restart
    PARSER_RESTART = SUBPARSERS.add_parser('restart', help='Restart components')
    PARSER_RESTART.add_argument('components', nargs='*', default='*', type=get_components, help='Stop and start a specific component(s) or glob match. COMPONENTS: {}'.format(', '.join(CUR_COMPONENTS)))
    PARSER_RESTART.add_argument('--update-images', '-u', action='store_true', help='Look for images that components are using, and try to either build new versions, or pull new ones')
    PARSER_RESTART.set_defaults(func=devlab_bench.actions.restart.action)

    #Parse our args
    try:
        ARGS = PARSER.parse_args(set_default_action(args=sys.argv[1:], subparser=SUBPARSERS))
    except DevlabComponentError as exc:
        print('ERROR during parsing of aguments: {}'.format(exc))
        sys.exit(1)

    if ARGS.version:
        print('Version: {}'.format(__VERSION__))
        sys.exit(0)

    #Initialize logging:
    logging_init(level=ARGS.log_level)
    LOGGER = logging.getLogger("Main")

    #The 'update' action is special and doesn't need all of the checks or a devlab_bench.PROJ_ROOT etc..
    #it also will exit after executing
    if ARGS.func in [action_update, action_global_status, action_default]:
        ARGS.func(**vars(ARGS))

    if ARGS.project_root:
        devlab_bench.PROJ_ROOT = ARGS.project_root

    if not devlab_bench.PROJ_ROOT:
        #Running Adhoc without a project won't get us a DockerHelper object.
        #this will create one if none has been set.
        if ARGS.func == devlab_bench.actions.shell.action and ARGS.components == ['adhoc']:
            devlab_bench.PROJ_ROOT = os.path.abspath('.')
            devlab_bench.helpers.docker.DOCKER = DockerHelper(
                labels=[
                    'com.lab.type=devlab',
                    'com.lab.project={}'.format(devlab_bench.PROJ_ROOT)
                ]
            )
            devlab_bench.CONFIG = {
                'network': {
                    'name': None
                }
            }
            # Run the adhoc function
            ARGS.func(**vars(ARGS))
            sys.exit(0)
        else:
            LOGGER.error("Aborting... could not determine project root. Please create a DevlabConfig.json or DevlabConfig.yaml etc...")
            sys.exit(1)

    #Load config
    devlab_bench.CONFIG = get_config()

    #If we're doing an 'up' action, check for and run wizard
    if ARGS.func == devlab_bench.actions.up.action:
        if devlab_bench.CONFIG['wizard_enabled']:
            if os.path.isfile('{}/wizard'.format(devlab_bench.PROJ_ROOT)):
                LOGGER.debug("Running wizard, in case it needs to be run")
                WIZ_OUT = Command('{}/wizard'.format(devlab_bench.PROJ_ROOT), interactive=True).run()
                if WIZ_OUT[0] != 0:
                    LOGGER.error("Wizard did not exit successfully... Aborting!")
                    sys.exit(1)
                devlab_bench.CONFIG = get_config(force_reload=True)
            else:
                LOGGER.warning("WARNING!!!!WARNING!!! No wizard found!!!")

    #See if we have enough details in our config
    if not devlab_bench.CONFIG['components'] and 'foreground_component' not in devlab_bench.CONFIG:
        LOGGER.warning("No devlab configuration was found yet.")
        LOGGER.info("Trying to load from 'defaults/'")
        devlab_bench.CONFIG = get_config(force_reload=True, fallback_default=True)
        if not devlab_bench.CONFIG['components']:
            LOGGER.error("No configured components found!... aborting")
            sys.exit(1)

    #Create our DockerHelper Object
    devlab_bench.helpers.docker.DOCKER = DockerHelper(
        filter_label=devlab_bench.CONFIG['project_filter'],
        labels=[
            'com.lab.type=devlab',
            'com.lab.project={}'.format(devlab_bench.PROJ_ROOT)
        ],
        common_domain=devlab_bench.CONFIG['domain']
    )

    #Change directory to the root of the project
    os.chdir(devlab_bench.PROJ_ROOT)

    #Run the action function
    ARGS.func(**vars(ARGS))
